{"version":3,"file":"Line2Helper-D4QmpFuS.js","sources":["../node_modules/.pnpm/three@0.170.0/node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js","../node_modules/.pnpm/three@0.170.0/node_modules/three/examples/jsm/lines/LineMaterial.js","../node_modules/.pnpm/three@0.170.0/node_modules/three/examples/jsm/lines/LineSegments2.js","../src/core/dxf-viewer-library/Line2Helper.js"],"sourcesContent":["import {\n\tBox3,\n\tFloat32BufferAttribute,\n\tInstancedBufferGeometry,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tSphere,\n\tVector3,\n\tWireframeGeometry\n} from 'three';\n\nconst _box = new Box3();\nconst _vector = new Vector3();\n\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isLineSegmentsGeometry = true;\n\n\t\tthis.type = 'LineSegmentsGeometry';\n\n\t\tconst positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\t\tconst uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];\n\t\tconst index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];\n\n\t\tthis.setIndex( index );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined ) {\n\n\t\t\tstart.applyMatrix4( matrix );\n\n\t\t\tend.applyMatrix4( matrix );\n\n\t\t\tstart.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetPositions( array ) {\n\n\t\tlet lineSegments;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tlineSegments = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tlineSegments = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz\n\n\t\tthis.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz\n\t\tthis.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz\n\n\t\tthis.instanceCount = this.attributes.instanceStart.count;\n\n\t\t//\n\n\t\tthis.computeBoundingBox();\n\t\tthis.computeBoundingSphere();\n\n\t\treturn this;\n\n\t}\n\n\tsetColors( array ) {\n\n\t\tlet colors;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\tcolors = array;\n\n\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\tcolors = new Float32Array( array );\n\n\t\t}\n\n\t\tconst instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb\n\n\t\tthis.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb\n\t\tthis.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb\n\n\t\treturn this;\n\n\t}\n\n\tfromWireframeGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromEdgesGeometry( geometry ) {\n\n\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\treturn this;\n\n\t}\n\n\tfromMesh( mesh ) {\n\n\t\tthis.fromWireframeGeometry( new WireframeGeometry( mesh.geometry ) );\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tfromLineSegments( lineSegments ) {\n\n\t\tconst geometry = lineSegments.geometry;\n\n\t\tthis.setPositions( geometry.attributes.position.array ); // assumes non-indexed\n\n\t\t// set colors, maybe\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( start );\n\n\t\t\t_box.setFromBufferAttribute( end );\n\n\t\t\tthis.boundingBox.union( _box );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tconst start = this.attributes.instanceStart;\n\t\tconst end = this.attributes.instanceEnd;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\tthis.boundingBox.getCenter( center );\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = start.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( start, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t_vector.fromBufferAttribute( end, i );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON() {\n\n\t\t// todo\n\n\t}\n\n\tapplyMatrix( matrix ) {\n\n\t\tconsole.warn( 'THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().' );\n\n\t\treturn this.applyMatrix4( matrix );\n\n\t}\n\n}\n\nexport { LineSegmentsGeometry };\n","import {\n\tShaderLib,\n\tShaderMaterial,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector2,\n} from 'three';\n\nUniformsLib.line = {\n\n\tworldUnits: { value: 1 },\n\tlinewidth: { value: 1 },\n\tresolution: { value: new Vector2( 1, 1 ) },\n\tdashOffset: { value: 0 },\n\tdashScale: { value: 1 },\n\tdashSize: { value: 1 },\n\tgapSize: { value: 1 } // todo FIX - maybe change to totalSize\n\n};\n\nShaderLib[ 'line' ] = {\n\n\tuniforms: UniformsUtils.merge( [\n\t\tUniformsLib.common,\n\t\tUniformsLib.fog,\n\t\tUniformsLib.line\n\t] ),\n\n\tvertexShader:\n\t/* glsl */`\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );\n\t\t\t\tvec3 worldUp = normalize( cross( worldDir, tmpFwd ) );\n\t\t\t\tvec3 worldFwd = cross( worldDir, worldUp );\n\t\t\t\tworldPos = position.y < 0.5 ? start: end;\n\n\t\t\t\t// height offset\n\t\t\t\tfloat hw = linewidth * 0.5;\n\t\t\t\tworldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.xyz += worldFwd * hw;\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\tworldPos.xyz -= worldFwd * 2.0 * hw;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n\n\tfragmentShader:\n\t/* glsl */`\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends ShaderMaterial {\n\n\n\tstatic get type() {\n\n\t\treturn 'LineMaterial';\n\n\t}\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tuniforms: UniformsUtils.clone( ShaderLib[ 'line' ].uniforms ),\n\n\t\t\tvertexShader: ShaderLib[ 'line' ].vertexShader,\n\t\t\tfragmentShader: ShaderLib[ 'line' ].fragmentShader,\n\n\t\t\tclipping: true // required for clipping support\n\n\t\t} );\n\n\t\tthis.isLineMaterial = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tget color() {\n\n\t\treturn this.uniforms.diffuse.value;\n\n\t}\n\n\tset color( value ) {\n\n\t\tthis.uniforms.diffuse.value = value;\n\n\t}\n\n\tget worldUnits() {\n\n\t\treturn 'WORLD_UNITS' in this.defines;\n\n\t}\n\n\tset worldUnits( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.WORLD_UNITS = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.WORLD_UNITS;\n\n\t\t}\n\n\t}\n\n\tget linewidth() {\n\n\t\treturn this.uniforms.linewidth.value;\n\n\t}\n\n\tset linewidth( value ) {\n\n\t\tif ( ! this.uniforms.linewidth ) return;\n\t\tthis.uniforms.linewidth.value = value;\n\n\t}\n\n\tget dashed() {\n\n\t\treturn 'USE_DASH' in this.defines;\n\n\t}\n\n\tset dashed( value ) {\n\n\t\tif ( ( value === true ) !== this.dashed ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.USE_DASH = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.USE_DASH;\n\n\t\t}\n\n\t}\n\n\tget dashScale() {\n\n\t\treturn this.uniforms.dashScale.value;\n\n\t}\n\n\tset dashScale( value ) {\n\n\t\tthis.uniforms.dashScale.value = value;\n\n\t}\n\n\tget dashSize() {\n\n\t\treturn this.uniforms.dashSize.value;\n\n\t}\n\n\tset dashSize( value ) {\n\n\t\tthis.uniforms.dashSize.value = value;\n\n\t}\n\n\tget dashOffset() {\n\n\t\treturn this.uniforms.dashOffset.value;\n\n\t}\n\n\tset dashOffset( value ) {\n\n\t\tthis.uniforms.dashOffset.value = value;\n\n\t}\n\n\tget gapSize() {\n\n\t\treturn this.uniforms.gapSize.value;\n\n\t}\n\n\tset gapSize( value ) {\n\n\t\tthis.uniforms.gapSize.value = value;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.uniforms.opacity.value;\n\n\t}\n\n\tset opacity( value ) {\n\n\t\tif ( ! this.uniforms ) return;\n\t\tthis.uniforms.opacity.value = value;\n\n\t}\n\n\tget resolution() {\n\n\t\treturn this.uniforms.resolution.value;\n\n\t}\n\n\tset resolution( value ) {\n\n\t\tthis.uniforms.resolution.value.copy( value );\n\n\t}\n\n\tget alphaToCoverage() {\n\n\t\treturn 'USE_ALPHA_TO_COVERAGE' in this.defines;\n\n\t}\n\n\tset alphaToCoverage( value ) {\n\n\t\tif ( ! this.defines ) return;\n\n\t\tif ( ( value === true ) !== this.alphaToCoverage ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.defines.USE_ALPHA_TO_COVERAGE = '';\n\n\t\t} else {\n\n\t\t\tdelete this.defines.USE_ALPHA_TO_COVERAGE;\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineMaterial };\n","import {\n\tBox3,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tSphere,\n\tVector3,\n\tVector4\n} from 'three';\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry.js';\nimport { LineMaterial } from '../lines/LineMaterial.js';\n\nconst _viewport = new Vector4();\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\n\nlet _ray, _lineWidth;\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth( camera, distance, resolution ) {\n\n\t// transform into clip space, adjust the x and y values by the pixel width offset, then\n\t// transform back into world space to get world offset. Note clip space is [-1, 1] so full\n\t// width does not need to be halved.\n\t_clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\t_clipToWorldVector.x = _lineWidth / resolution.width;\n\t_clipToWorldVector.y = _lineWidth / resolution.height;\n\t_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\n\treturn Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );\n\n}\n\nfunction raycastWorldUnits( lineSegments, intersects ) {\n\n\tconst matrixWorld = lineSegments.matrixWorld;\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t_line.applyMatrix4( matrixWorld );\n\n\t\tconst pointOnLine = new Vector3();\n\t\tconst point = new Vector3();\n\n\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\t\tconst isInside = point.distanceTo( pointOnLine ) < _lineWidth * 0.5;\n\n\t\tif ( isInside ) {\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint,\n\t\t\t\tpointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nfunction raycastScreenSpace( lineSegments, camera, intersects ) {\n\n\tconst projectionMatrix = camera.projectionMatrix;\n\tconst material = lineSegments.material;\n\tconst resolution = material.resolution;\n\tconst matrixWorld = lineSegments.matrixWorld;\n\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tconst near = - camera.near;\n\n\t//\n\n\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t// applying the projection matrix.\n\t_ray.at( 1, _ssOrigin );\n\n\t// ndc space [ - 1.0, 1.0 ]\n\t_ssOrigin.w = 1;\n\t_ssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t_ssOrigin.applyMatrix4( projectionMatrix );\n\t_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );\n\n\t// screen space\n\t_ssOrigin.x *= resolution.x / 2;\n\t_ssOrigin.y *= resolution.y / 2;\n\t_ssOrigin.z = 0;\n\n\t_ssOrigin3.copy( _ssOrigin );\n\n\t_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_start4.fromBufferAttribute( instanceStart, i );\n\t\t_end4.fromBufferAttribute( instanceEnd, i );\n\n\t\t_start4.w = 1;\n\t\t_end4.w = 1;\n\n\t\t// camera space\n\t\t_start4.applyMatrix4( _mvMatrix );\n\t\t_end4.applyMatrix4( _mvMatrix );\n\n\t\t// skip the segment if it's entirely behind the camera\n\t\tconst isBehindCameraNear = _start4.z > near && _end4.z > near;\n\t\tif ( isBehindCameraNear ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// trim the segment if it extends behind camera near\n\t\tif ( _start4.z > near ) {\n\n\t\t\tconst deltaDist = _start4.z - _end4.z;\n\t\t\tconst t = ( _start4.z - near ) / deltaDist;\n\t\t\t_start4.lerp( _end4, t );\n\n\t\t} else if ( _end4.z > near ) {\n\n\t\t\tconst deltaDist = _end4.z - _start4.z;\n\t\t\tconst t = ( _end4.z - near ) / deltaDist;\n\t\t\t_end4.lerp( _start4, t );\n\n\t\t}\n\n\t\t// clip space\n\t\t_start4.applyMatrix4( projectionMatrix );\n\t\t_end4.applyMatrix4( projectionMatrix );\n\n\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t_start4.multiplyScalar( 1 / _start4.w );\n\t\t_end4.multiplyScalar( 1 / _end4.w );\n\n\t\t// screen space\n\t\t_start4.x *= resolution.x / 2;\n\t\t_start4.y *= resolution.y / 2;\n\n\t\t_end4.x *= resolution.x / 2;\n\t\t_end4.y *= resolution.y / 2;\n\n\t\t// create 2d segment\n\t\t_line.start.copy( _start4 );\n\t\t_line.start.z = 0;\n\n\t\t_line.end.copy( _end4 );\n\t\t_line.end.z = 0;\n\n\t\t// get closest point on ray to segment\n\t\tconst param = _line.closestPointToPointParameter( _ssOrigin3, true );\n\t\t_line.at( param, _closestPoint );\n\n\t\t// check if the intersection point is within clip space\n\t\tconst zPos = MathUtils.lerp( _start4.z, _end4.z, param );\n\t\tconst isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\tconst isInside = _ssOrigin3.distanceTo( _closestPoint ) < _lineWidth * 0.5;\n\n\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t_line.start.applyMatrix4( matrixWorld );\n\t\t\t_line.end.applyMatrix4( matrixWorld );\n\n\t\t\tconst pointOnLine = new Vector3();\n\t\t\tconst point = new Vector3();\n\n\t\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint: point,\n\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nclass LineSegments2 extends Mesh {\n\n\tconstructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineSegments2 = true;\n\n\t\tthis.type = 'LineSegments2';\n\n\t}\n\n\t// for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\t\tconst lineDistances = new Float32Array( 2 * instanceStart.count );\n\n\t\tfor ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {\n\n\t\t\t_start.fromBufferAttribute( instanceStart, i );\n\t\t\t_end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );\n\n\t\t}\n\n\t\tconst instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst worldUnits = this.material.worldUnits;\n\t\tconst camera = raycaster.camera;\n\n\t\tif ( camera === null && ! worldUnits ) {\n\n\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.' );\n\n\t\t}\n\n\t\tconst threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\t_ray = raycaster.ray;\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\t_lineWidth = material.linewidth + threshold;\n\n\t\t// check if we intersect the sphere bounds\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );\n\n\t\t// increase the sphere bounds by the worst case line screen space width\n\t\tlet sphereMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tsphereMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( _ray.origin ) );\n\t\t\tsphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, material.resolution );\n\n\t\t}\n\n\t\t_sphere.radius += sphereMargin;\n\n\t\tif ( _ray.intersectsSphere( _sphere ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if we intersect the box bounds\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\t_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );\n\n\t\t// increase the box bounds by the worst case line width\n\t\tlet boxMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tboxMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToBox = Math.max( camera.near, _box.distanceToPoint( _ray.origin ) );\n\t\t\tboxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, material.resolution );\n\n\t\t}\n\n\t\t_box.expandByScalar( boxMargin );\n\n\t\tif ( _ray.intersectsBox( _box ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( worldUnits ) {\n\n\t\t\traycastWorldUnits( this, intersects );\n\n\t\t} else {\n\n\t\t\traycastScreenSpace( this, camera, intersects );\n\n\t\t}\n\n\t}\n\n\tonBeforeRender( renderer ) {\n\n\t\tconst uniforms = this.material.uniforms;\n\n\t\tif ( uniforms && uniforms.resolution ) {\n\n\t\t\trenderer.getViewport( _viewport );\n\t\t\tthis.material.uniforms.resolution.value.set( _viewport.z, _viewport.w );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineSegments2 };\n","import * as THREE from \"three\";\nimport { LineSegments2 } from \"three/examples/jsm/lines/LineSegments2.js\";\nimport { LineMaterial } from \"three/examples/jsm/lines/LineMaterial.js\";\nimport { LineSegmentsGeometry } from \"three/examples/jsm/lines/LineSegmentsGeometry.js\";\n\nexport const sharedResolution = new THREE.Vector2(1, 1);\nconst lineMaterialCache = new Map();\n\nexport function updateResolution(width, height) {\n    sharedResolution.set(width, height);\n    lineMaterialCache.forEach(mat => {\n        mat.resolution.copy(sharedResolution);\n        mat.needsUpdate = true;\n    });\n}\n\nexport function getLineMaterial(color, linewidth = 3, opacity = 1.0) {\n    const key = `${color}-${linewidth}-${opacity}`;\n    if (lineMaterialCache.has(key)) {\n        const mat = lineMaterialCache.get(key);\n        // Ensure resolution is up to date\n        if (mat.resolution.x !== sharedResolution.x || mat.resolution.y !== sharedResolution.y) {\n             mat.resolution.copy(sharedResolution);\n             mat.needsUpdate = true;\n        }\n        return mat;\n    }\n    const material = new LineMaterial({\n        color: new THREE.Color(color),\n        linewidth: linewidth,\n        resolution: sharedResolution, // Binds to shared vector\n        dashed: false,\n        worldUnits: false, // Use screen-space width\n        depthTest: false, // Ensure overlays render on top\n        transparent: true,\n        opacity,\n    });\n    lineMaterialCache.set(key, material);\n    return material;\n}\n\nexport function clearLineMaterialCache() {\n    lineMaterialCache.forEach(mat => mat.dispose());\n    lineMaterialCache.clear();\n}\n\n/**\n * Creates an overlay from an existing LineSegments object.\n * WARNING: Fails for batched geometry where positions are shared.\n * Use createOverlayFromCoordinates instead.\n */\nexport function createOverlay(originalObject, material) {\n    if (!originalObject.geometry) return null;\n    const geometry = new LineSegmentsGeometry();\n    const positions = [];\n    const attr = originalObject.geometry.getAttribute('position');\n    if (!attr) return null;\n    const array = attr.array;\n    const itemSize = attr.itemSize;\n    const count = attr.count;\n    \n    // Check if we can just use the array directly (if it's not interleaved or weird)\n    // For safety with LineSegments, we assume pairs\n    \n    const pushVertex = (index) => {\n        const x = Number(array[index * itemSize]);\n        const y = Number(array[index * itemSize + 1]);\n        const z = itemSize >= 3 ? Number(array[index * itemSize + 2]) : 0;\n        \n        if (isNaN(x) || isNaN(y) || isNaN(z)) {\n            positions.push(0, 0, 0);\n        } else {\n            positions.push(x, y, z);\n        }\n    };\n\n    if (originalObject.geometry.index) {\n        const indexArray = originalObject.geometry.index.array;\n        for (let i = 0; i < indexArray.length; i++) pushVertex(indexArray[i]);\n    } else {\n        for (let i = 0; i < count; i++) pushVertex(i);\n    }\n    \n    geometry.setPositions(positions);\n    geometry.computeBoundingBox();\n    geometry.computeBoundingSphere();\n    \n    const overlay = new LineSegments2(geometry, material);\n    originalObject.updateMatrixWorld();\n    overlay.matrix.copy(originalObject.matrixWorld);\n    overlay.matrixAutoUpdate = false;\n    overlay.renderOrder = 999;\n    \n    // Force compute LineSegments2 bounding info\n    overlay.computeLineDistances();\n    \n    return overlay;\n}\n\n/**\n * Creates an overlay from a set of logical coordinates (polyline vertices).\n * Automatically generates segment pairs for LineSegments2.\n * @param {Array<{x:number, y:number, z?:number}>} vertices - Array of points\n * @param {boolean} isClosed - Whether to close the loop\n * @param {THREE.Matrix4} transform - Optional transform to apply (e.g. object world matrix)\n */\nexport function createOverlayFromCoordinates(vertices, material, isClosed = false, transform = null) {\n    if (!vertices || vertices.length < 2) return null;\n\n    const positions = [];\n    \n    for (let i = 0; i < vertices.length - 1; i++) {\n        const p1 = vertices[i];\n        const p2 = vertices[i+1];\n        \n        // Safety check for NaN or undefined\n        const x1 = Number(p1.x), y1 = Number(p1.y), z1 = Number(p1.z || 0);\n        const x2 = Number(p2.x), y2 = Number(p2.y), z2 = Number(p2.z || 0);\n        \n        if (isNaN(x1) || isNaN(y1) || isNaN(z1) || isNaN(x2) || isNaN(y2) || isNaN(z2)) {\n            continue;\n        }\n\n        positions.push(x1, y1, z1);\n        positions.push(x2, y2, z2);\n    }\n\n    if (isClosed && vertices.length > 2) {\n        const p1 = vertices[vertices.length - 1];\n        const p2 = vertices[0];\n        \n        const x1 = Number(p1.x), y1 = Number(p1.y), z1 = Number(p1.z || 0);\n        const x2 = Number(p2.x), y2 = Number(p2.y), z2 = Number(p2.z || 0);\n        \n        if (!isNaN(x1) && !isNaN(y1) && !isNaN(z1) && !isNaN(x2) && !isNaN(y2) && !isNaN(z2)) {\n            positions.push(x1, y1, z1);\n            positions.push(x2, y2, z2);\n        }\n    }\n\n    if (positions.length === 0) return null;\n\n    const geometry = new LineSegmentsGeometry();\n    geometry.setPositions(positions);\n    \n    // CRITICAL for visibility: Compute bounding volumes\n    geometry.computeBoundingBox();\n    geometry.computeBoundingSphere();\n    \n    const overlay = new LineSegments2(geometry, material);\n    if (transform) {\n        overlay.matrix.copy(transform);\n        overlay.matrixAutoUpdate = false;\n    }\n    overlay.renderOrder = 999;\n    \n    // Force compute LineSegments2 bounding info\n    overlay.computeLineDistances();\n    \n    return overlay;\n}\n"],"names":["_box","Box3","_vector","Vector3","LineSegmentsGeometry","InstancedBufferGeometry","positions","uvs","index","Float32BufferAttribute","matrix","start","end","array","lineSegments","instanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","colors","instanceColorBuffer","geometry","mesh","WireframeGeometry","Sphere","center","maxRadiusSq","i","il","UniformsLib","Vector2","ShaderLib","UniformsUtils","LineMaterial","ShaderMaterial","parameters","value","_viewport","Vector4","_start","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","Matrix4","_line","Line3","_closestPoint","_sphere","_clipToWorldVector","_ray","_lineWidth","getWorldSpaceHalfWidth","camera","distance","resolution","raycastWorldUnits","intersects","matrixWorld","instanceStart","instanceEnd","segmentCount","l","pointOnLine","point","raycastScreenSpace","projectionMatrix","near","deltaDist","t","param","zPos","MathUtils","isInClipSpace","isInside","LineSegments2","Mesh","material","lineDistances","j","instanceDistanceBuffer","raycaster","worldUnits","threshold","sphereMargin","distanceToSphere","boxMargin","distanceToBox","renderer","uniforms","sharedResolution","THREE","lineMaterialCache","updateResolution","width","height","mat","getLineMaterial","color","linewidth","opacity","key","clearLineMaterialCache","createOverlay","originalObject","attr","itemSize","count","pushVertex","x","y","z","indexArray","overlay","createOverlayFromCoordinates","vertices","isClosed","transform","p1","p2","x1","y1","z1","x2","y2","z2"],"mappings":"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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqNV;AAAA;AAAA,IACU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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","x_google_ignoreList":[0,1,2]}